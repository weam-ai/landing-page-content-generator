const express = require('express');
const router = express.Router();
const BusinessInfo = require('../models/BusinessInfo');
const WebsiteScraper = require('../utils/websiteScraper');
// const { protect } = require('../middleware/auth'); // Removed protect middleware
const { body, validationResult } = require('express-validator');
const logger = require('../utils/logger');

// Initialize website scraper
const websiteScraper = new WebsiteScraper();

/**
 * @route   GET /api/business-info
 * @desc    Get all business information for authenticated user
 * @access  Private
 */
router.get('/', async (req, res) => {
  try {
    const businessInfo = await BusinessInfo.find({ user: req.user.id })
      .sort({ createdAt: -1 });

    res.json({
      success: true,
      count: businessInfo.length,
      data: businessInfo
    });
  } catch (error) {
    logger.error('Error fetching business info:', error);
    res.status(500).json({
      success: false,
      error: 'Server error'
    });
  }
});

/**
 * @route   GET /api/business-info/:id
 * @desc    Get specific business information by ID
 * @access  Private
 */
router.get('/:id', async (req, res) => {
  try {
    const businessInfo = await BusinessInfo.findById(req.params.id);

    if (!businessInfo) {
      return res.status(404).json({
        success: false,
        error: 'Business information not found'
      });
    }

    // Check if user owns this business info
    if (businessInfo.user.toString() !== req.user.id) {
      return res.status(401).json({
        success: false,
        error: 'Not authorized to access this business information'
      });
    }

    res.json({
      success: true,
      data: businessInfo
    });
  } catch (error) {
    logger.error('Error fetching business info by ID:', error);
    res.status(500).json({
      success: false,
      error: 'Server error'
    });
  }
});

/**
 * @route   POST /api/business-info
 * @desc    Create new business information
 * @access  Private
 */
router.post('/', [
  [
    body('businessName', 'Business name is required').notEmpty().trim(),
    body('businessOverview', 'Business overview is required').notEmpty().trim(),
    body('targetAudience', 'Target audience is required').notEmpty().trim(),
    body('brandTone').optional().isIn(['professional', 'friendly', 'playful', 'authoritative', 'casual']),
    body('websiteUrl').optional().isURL().withMessage('Please provide a valid URL')
  ]
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }

    const {
      businessName,
      businessOverview,
      targetAudience,
      brandTone,
      websiteUrl,
      tags
    } = req.body;

    const businessInfo = new BusinessInfo({
      user: req.user.id,
      businessName,
      businessOverview,
      targetAudience,
      brandTone,
      websiteUrl,
      tags: tags || []
    });

    await businessInfo.save();

    res.status(201).json({
      success: true,
      data: businessInfo
    });
  } catch (error) {
    logger.error('Error creating business info:', error);
    res.status(500).json({
      success: false,
      error: 'Server error'
    });
  }
});

/**
 * @route   POST /api/business-info/auto-generate
 * @desc    Auto-generate business information from website URL
 */
router.post('/auto-generate', [
  body('websiteUrl', 'Website URL is required').isURL().withMessage('Please provide a valid URL'),
  body('businessName', 'Business name is required').notEmpty().trim(),
  body('businessOverview', 'Business overview is required').notEmpty().trim(),
  body('targetAudience', 'Target audience is required').notEmpty().trim()
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }

    const {
      websiteUrl,
      businessName,
      businessOverview,
      targetAudience,
      brandTone,
      tags
    } = req.body;

    // Start auto-generation process
    logger.info(`Starting auto-generation for URL: ${websiteUrl}`);

    // Scrape and analyze website
    const autoGeneratedData = await websiteScraper.scrapeAndAnalyze(websiteUrl);

    // Create business info with auto-generated data
    const businessInfo = new BusinessInfo({
      user: req.user.id,
      businessName,
      businessOverview,
      targetAudience,
      brandTone,
      websiteUrl,
      tags: tags || [],
      autoGenerated: autoGeneratedData
    });

    await businessInfo.save();

    logger.info(`Successfully auto-generated business info for: ${websiteUrl}`);

    res.status(201).json({
      success: true,
      message: 'Business information auto-generated successfully',
      data: businessInfo
    });

  } catch (error) {
    logger.error('Error auto-generating business info:', error);
    
    // Handle specific errors with user-friendly messages
    if (error.message.includes('blocking automated access') || 
        error.message.includes('403 Forbidden') ||
        error.message.includes('blocked') ||
        error.message.includes('security')) {
      return res.status(403).json({
        success: false,
        error: 'Due to security restrictions on your provided URL, we were not able to generate business information automatically. Please try a different website or provide your business details manually.'
      });
    }
    
    if (error.message.includes('Failed to scrape website') ||
        error.message.includes('not accessible') ||
        error.message.includes('ENOTFOUND') ||
        error.message.includes('ECONNREFUSED')) {
      return res.status(400).json({
        success: false,
        error: 'Unable to access the website. Please check the URL and try again.'
      });
    }
    
    if (error.message.includes('timeout') ||
        error.message.includes('took too long')) {
      return res.status(408).json({
        success: false,
        error: 'The website took too long to respond. Please try again or use a different website.'
      });
    }
    
    if (error.message.includes('Failed to analyze content with AI') ||
        error.message.includes('AI analysis')) {
      return res.status(500).json({
        success: false,
        error: 'AI analysis failed. Please try again or use manual input.'
      });
    }

    // Generic error for any other issues
    res.status(500).json({
      success: false,
      error: 'Unable to generate business information automatically. Please try a different website or provide your business details manually.'
    });
  }
});

/**
 * @route   POST /api/business-info/auto-generate-public
 * @desc    Auto-generate business information from website URL (Public - for testing)
 * @access  Public
 */
router.post('/auto-generate-public', [
  [
    body('websiteUrl', 'Website URL is required').isURL().withMessage('Please provide a valid URL'),
    body('businessName', 'Business name is required').notEmpty().trim(),
    body('businessOverview', 'Business overview is required').notEmpty().trim(),
    body('targetAudience', 'Target audience is required').notEmpty().trim()
  ]
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }

    const {
      websiteUrl,
      businessName,
      businessOverview,
      targetAudience,
      brandTone,
      tags
    } = req.body;

    // Start auto-generation process
    logger.info(`Starting auto-generation for URL: ${websiteUrl}`);

    // Scrape and analyze website
    const autoGeneratedData = await websiteScraper.scrapeAndAnalyze(websiteUrl);

    // Return the auto-generated data without saving to database
    logger.info(`Successfully auto-generated business info for: ${websiteUrl}`);

    res.status(200).json({
      success: true,
      message: 'Business information auto-generated successfully',
      data: {
        businessName,
        businessOverview,
        targetAudience,
        brandTone,
        websiteUrl,
        tags: tags || [],
        autoGenerated: autoGeneratedData
      }
    });

  } catch (error) {
    logger.error('Error auto-generating business info:', error);
    
    // Handle specific errors with user-friendly messages
    if (error.message.includes('blocking automated access') || 
        error.message.includes('403 Forbidden') ||
        error.message.includes('blocked') ||
        error.message.includes('security')) {
      return res.status(403).json({
        success: false,
        error: 'Due to security restrictions on your provided URL, we were not able to generate business information automatically. Please try a different website or provide your business details manually.'
      });
    }
    
    if (error.message.includes('Failed to scrape website') ||
        error.message.includes('not accessible') ||
        error.message.includes('ENOTFOUND') ||
        error.message.includes('ECONNREFUSED')) {
      return res.status(400).json({
        success: false,
        error: 'Unable to access the website. Please check the URL and try again.'
      });
    }
    
    if (error.message.includes('timeout') ||
        error.message.includes('took too long')) {
      return res.status(408).json({
        success: false,
        error: 'The website took too long to respond. Please try again or use a different website.'
      });
    }
    
    if (error.message.includes('Failed to analyze content with AI') ||
        error.message.includes('AI analysis')) {
      return res.status(500).json({
        success: false,
        error: 'AI analysis failed. Please try again or use manual input.'
      });
    }

    // Generic error for any other issues
    res.status(500).json({
      success: false,
      error: 'Unable to generate business information automatically. Please try a different website or provide your business details manually.'
    });
  }
});

/**
 * @route   PUT /api/business-info/:id
 * @desc    Update business information
 * @access  Private
 */
router.put('/:id', [
  [
    body('businessName').optional().notEmpty().trim(),
    body('businessOverview').optional().notEmpty().trim(),
    body('targetAudience').optional().notEmpty().trim(),
    body('brandTone').optional().isIn(['professional', 'friendly', 'playful', 'authoritative', 'casual']),
    body('websiteUrl').optional().isURL().withMessage('Please provide a valid URL')
  ]
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }

    let businessInfo = await BusinessInfo.findById(req.params.id);

    if (!businessInfo) {
      return res.status(404).json({
        success: false,
        error: 'Business information not found'
      });
    }

    // Check if user owns this business info
    if (businessInfo.user.toString() !== req.user.id) {
      return res.status(401).json({
        success: false,
        error: 'Not authorized to update this business information'
      });
    }

    // Update fields
    const updateFields = {};
    ['businessName', 'businessOverview', 'targetAudience', 'brandTone', 'websiteUrl', 'tags'].forEach(field => {
      if (req.body[field] !== undefined) {
        updateFields[field] = req.body[field];
      }
    });

    businessInfo = await BusinessInfo.findByIdAndUpdate(
      req.params.id,
      updateFields,
      { new: true, runValidators: true }
    );

    res.json({
      success: true,
      data: businessInfo
    });
  } catch (error) {
    logger.error('Error updating business info:', error);
    res.status(500).json({
      success: false,
      error: 'Server error'
    });
  }
});

/**
 * @route   PUT /api/business-info/:id/manual-override
 * @desc    Update manual override fields
 * @access  Private
 */
router.put('/:id/manual-override', [
  [
    body('manualOverrides').isObject().withMessage('Manual overrides must be an object')
  ]
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        errors: errors.array()
      });
    }

    let businessInfo = await BusinessInfo.findById(req.params.id);

    if (!businessInfo) {
      return res.status(404).json({
        success: false,
        error: 'Business information not found'
      });
    }

    // Check if user owns this business info
    if (businessInfo.user.toString() !== req.user.id) {
      return res.status(401).json({
        success: false,
        error: 'Not authorized to update this business information'
      });
    }

    // Update manual overrides
    businessInfo.manualOverrides = {
      ...businessInfo.manualOverrides,
      ...req.body.manualOverrides
    };

    await businessInfo.save();

    res.json({
      success: true,
      data: businessInfo
    });
  } catch (error) {
    logger.error('Error updating manual overrides:', error);
    res.status(500).json({
      success: false,
      error: 'Server error'
    });
  }
});

/**
 * @route   DELETE /api/business-info/:id
 * @desc    Delete business information
 * @access  Private
 */
router.delete('/:id', async (req, res) => {
  try {
    const businessInfo = await BusinessInfo.findById(req.params.id);

    if (!businessInfo) {
      return res.status(404).json({
        success: false,
        error: 'Business information not found'
      });
    }

    // Check if user owns this business info
    if (businessInfo.user.toString() !== req.user.id) {
      return res.status(401).json({
        success: false,
        error: 'Not authorized to delete this business information'
      });
    }

    await businessInfo.deleteOne();

    res.json({
      success: true,
      message: 'Business information deleted successfully'
    });
  } catch (error) {
    logger.error('Error deleting business info:', error);
    res.status(500).json({
      success: false,
      error: 'Server error'
    });
  }
});

/**
 * @route   POST /api/business-info/:id/regenerate
 * @desc    Regenerate auto-generated content from website URL
 * @access  Private
 */
router.post('/:id/regenerate', async (req, res) => {
  try {
    const businessInfo = await BusinessInfo.findById(req.params.id);

    if (!businessInfo) {
      return res.status(404).json({
        success: false,
        error: 'Business information not found'
      });
    }

    // Check if user owns this business info
    if (businessInfo.user.toString() !== req.user.id) {
      return res.status(401).json({
        success: false,
        error: 'Not authorized to regenerate this business information'
      });
    }

    if (!businessInfo.websiteUrl) {
      return res.status(400).json({
        success: false,
        error: 'No website URL available for regeneration'
      });
    }

    // Regenerate auto-generated content
    const autoGeneratedData = await websiteScraper.scrapeAndAnalyze(businessInfo.websiteUrl);

    // Update auto-generated fields
    businessInfo.autoGenerated = autoGeneratedData;
    await businessInfo.save();

    logger.info(`Successfully regenerated business info for: ${businessInfo.websiteUrl}`);

    res.json({
      success: true,
      message: 'Business information regenerated successfully',
      data: businessInfo
    });

  } catch (error) {
    logger.error('Error regenerating business info:', error);
    
    if (error.message.includes('Failed to scrape website')) {
      return res.status(400).json({
        success: false,
        error: 'Unable to access the website. Please check the URL and try again.'
      });
    }

    res.status(500).json({
      success: false,
      error: 'Server error during regeneration'
    });
  }
});

module.exports = router;
